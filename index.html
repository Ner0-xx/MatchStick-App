<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matchstick Motion - Optimized Edition</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.7/dist/umd/ffmpeg.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@ffmpeg/util@0.12.1/dist/umd/index.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .file-input {
            display: none;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        .color-picker-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
        }

        .color-label {
            padding: 8px 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 0.9em;
            flex: 1;
        }

        input[type="range"] {
            width: 100%;
        }

        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 0.9em;
        }

        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background: #f5f5f5;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas, video, img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .placeholder {
            color: #999;
            text-align: center;
            padding: 40px;
        }

        .export-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .export-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.85em;
        }

        .status-message {
            margin-top: 15px;
            color: #666;
            font-size: 0.95em;
        }

        .warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .info-box {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #0c5460;
        }

        .quality-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.8em;
            margin-left: 10px;
        }

        .quality-fast {
            background: #28a745;
            color: white;
        }

        .quality-balanced {
            background: #ffc107;
            color: #333;
        }

        .quality-smooth {
            background: #17a2b8;
            color: white;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .panels {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üï∫ Matchstick Motion - OPTIMIZED</h1>
            <p class="subtitle">Maximum browser performance with smart optimizations</p>
            <div class="badge">‚ö° FFmpeg Encoder ‚Ä¢ Exact Frame Rate ‚Ä¢ MP4 Output</div>
        </header>

        <div class="info-box">
            <strong>‚ö° NEW: PROFESSIONAL ENCODER!</strong> Now using FFmpeg for perfect frame rate control, no dropped frames, and smooth MP4 output. This eliminates glitches caused by browser encoding!
        </div>

        <div class="controls">
            <div class="upload-section">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üìÅ Upload Photo or Video
                </button>
                <input type="file" id="fileInput" class="file-input" accept="image/*,video/*">
                <p style="margin-top: 10px; color: #666; font-size: 0.9em;">
                    Supports JPG, PNG, MP4, WebM ‚Ä¢ Best: 15-30 second clips
                </p>
            </div>

            <div id="videoWarning" class="warning hidden">
                ‚ö†Ô∏è Your video is longer than 45 seconds. For best performance, consider trimming to under 30 seconds.
            </div>

            <div id="processingControl" class="info-box hidden" style="text-align: center;">
                <p style="margin-bottom: 15px; font-weight: 600;">
                    ‚úÖ <span id="mediaInfo">Media loaded!</span> Adjust your settings above, then click Start Processing.
                </p>
                <button class="upload-btn" id="startProcessingBtn" style="margin: 0;">
                    üöÄ Start Processing
                </button>
            </div>

            <div class="settings-grid">
                <div class="setting-group">
                    <label>Processing Quality</label>
                    <select id="processingQuality">
                        <option value="fast">‚ö° Fast (Process every 3rd frame)</option>
                        <option value="balanced" selected>‚öñÔ∏è Balanced (Process every 2nd frame)</option>
                        <option value="smooth">‚ú® Smooth (Process all frames - slowest)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label>Output FPS</label>
                    <select id="outputFPS">
                        <option value="24">24 FPS (Cinematic)</option>
                        <option value="30" selected>30 FPS (Balanced)</option>
                        <option value="60">60 FPS (Smooth - requires more processing)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label>Stick Figure Glow Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="glowColor" value="#00ff88">
                        <span class="color-label" id="glowColorLabel">#00ff88</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>Background Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="bgColor" value="#1a1a2e">
                        <span class="color-label" id="bgColorLabel">#1a1a2e</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>Glow Intensity: <span id="glowValue">30</span>px</label>
                    <input type="range" id="glowIntensity" min="10" max="60" value="30">
                </div>

                <div class="setting-group">
                    <label>Line Thickness: <span id="thicknessValue">7</span>px</label>
                    <input type="range" id="lineThickness" min="3" max="15" value="7">
                </div>

                <div class="setting-group">
                    <label>Figure Scale: <span id="scaleValue">120</span>%</label>
                    <input type="range" id="figureScale" min="80" max="200" value="120" step="10">
                </div>

                <div class="setting-group">
                    <label>Interpolation Smoothness</label>
                    <select id="interpolationLevel">
                        <option value="0">Off (Fastest)</option>
                        <option value="3" selected>Medium (Balanced)</option>
                        <option value="5">High (Smoothest)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="panels">
            <div class="panel">
                <h2>üì∑ Original</h2>
                <div class="canvas-container" id="originalContainer">
                    <div class="placeholder">
                        <p>Upload a photo or video to get started!</p>
                        <p style="margin-top: 10px; font-size: 0.9em;">Optimized for dance and fast movements</p>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>‚ú® Matchstick Figure</h2>
                <div class="canvas-container" id="outputContainer">
                    <canvas id="outputCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="export-section">
            <h2 style="margin-bottom: 20px;">Export Your Creation</h2>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <p class="status-message" id="statusMessage">Processing...</p>
            </div>

            <div>
                <button class="export-btn" id="exportImageBtn" disabled>
                    üì∏ Download as Image
                </button>
                <button class="export-btn" id="exportVideoBtn" disabled>
                    üé• Download as Video (MP4)
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let pose = null;
        let currentMedia = null;
        let mediaType = null;
        let isProcessing = false;
        let videoFrames = [];
        let processedPoses = []; // Store detected poses for interpolation
        let currentFrame = 0;
        let animationId = null;
        let originalVideoDuration = 0;
        let originalVideoFPS = 30;

        // Canvas and context
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');

        // Settings
        let settings = {
            glowColor: '#00ff88',
            bgColor: '#1a1a2e',
            glowIntensity: 30,
            lineThickness: 7,
            figureScale: 1.2,
            processingQuality: 'balanced',
            outputFPS: 30,
            interpolationLevel: 3
        };

        // Initialize MediaPipe Pose with optimized settings
        async function initPose() {
            pose = new Pose({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                }
            });

            pose.setOptions({
                modelComplexity: 0, // Fastest model (0 = lite, 1 = full, 2 = heavy)
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.4,
                minTrackingConfidence: 0.4
            });

            pose.onResults(onPoseResults);
        }

        let currentPoseLandmarks = null;

        // Handle pose detection results
        function onPoseResults(results) {
            currentPoseLandmarks = results.poseLandmarks;
            
            if (!currentPoseLandmarks) return;

            // Set canvas size to match source
            outputCanvas.width = results.image.width;
            outputCanvas.height = results.image.height;

            // Clear and fill background
            ctx.fillStyle = settings.bgColor;
            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Draw the glowing stick figure
            drawGlowingStickFigure(currentPoseLandmarks);
        }

        // Linear interpolation between two poses
        function interpolatePoses(pose1, pose2, ratio) {
            if (!pose1 || !pose2) return pose1 || pose2;

            return pose1.map((landmark1, i) => {
                const landmark2 = pose2[i];
                if (!landmark1 || !landmark2) return landmark1 || landmark2;

                return {
                    x: landmark1.x + (landmark2.x - landmark1.x) * ratio,
                    y: landmark1.y + (landmark2.y - landmark1.y) * ratio,
                    z: landmark1.z + (landmark2.z - landmark1.z) * ratio,
                    visibility: Math.max(landmark1.visibility, landmark2.visibility)
                };
            });
        }

        // Get interpolated pose for smooth playback
        function getInterpolatedPose(frameIndex) {
            if (processedPoses.length === 0) return null;
            
            if (settings.interpolationLevel === 0) {
                // No interpolation - use nearest pose
                const nearestIndex = Math.min(frameIndex, processedPoses.length - 1);
                return processedPoses[nearestIndex];
            }

            // Find surrounding poses
            const poseIndex = frameIndex / settings.interpolationLevel;
            const lowerIndex = Math.floor(poseIndex);
            const upperIndex = Math.ceil(poseIndex);
            
            if (lowerIndex >= processedPoses.length) {
                return processedPoses[processedPoses.length - 1];
            }
            
            if (upperIndex >= processedPoses.length) {
                return processedPoses[lowerIndex];
            }

            const ratio = poseIndex - lowerIndex;
            return interpolatePoses(processedPoses[lowerIndex], processedPoses[upperIndex], ratio);
        }

        // Calculate bounding box for auto-scaling
        function getBoundingBox(landmarks) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            landmarks.forEach(landmark => {
                if (landmark && landmark.visibility > 0.2) {
                    minX = Math.min(minX, landmark.x);
                    minY = Math.min(minY, landmark.y);
                    maxX = Math.max(maxX, landmark.x);
                    maxY = Math.max(maxY, landmark.y);
                }
            });

            return { minX, minY, maxX, maxY };
        }

        // Draw glowing stick figure with optimizations
        function drawGlowingStickFigure(landmarks) {
            if (!landmarks) return;

            const w = outputCanvas.width;
            const h = outputCanvas.height;

            // Get bounding box for auto-scaling
            const bbox = getBoundingBox(landmarks);
            const bboxWidth = bbox.maxX - bbox.minX;
            const bboxHeight = bbox.maxY - bbox.minY;
            const centerX = (bbox.minX + bbox.maxX) / 2;
            const centerY = (bbox.minY + bbox.maxY) / 2;

            // Calculate scale
            const baseScale = Math.min(w / (bboxWidth * w), h / (bboxHeight * h)) * 0.7;
            const scale = baseScale * settings.figureScale;

            // Transform function
            const transform = (landmark) => {
                const scaledX = ((landmark.x - centerX) * scale) + 0.5;
                const scaledY = ((landmark.y - centerY) * scale) + 0.5;
                return {
                    x: scaledX * w,
                    y: scaledY * h,
                    visibility: landmark.visibility
                };
            };

            // Comprehensive body connections
            const connections = [
                // Core
                [11, 12], [11, 23], [12, 24], [23, 24],
                // Arms
                [11, 13], [13, 15], [12, 14], [14, 16],
                [15, 17], [15, 19], [15, 21], [16, 18], [16, 20], [16, 22],
                // Legs
                [23, 25], [25, 27], [24, 26], [26, 28],
                [27, 29], [27, 31], [28, 30], [28, 32],
                // Head (optional)
                [0, 1], [1, 2], [2, 3], [0, 4], [4, 5], [5, 6]
            ];

            // Setup glow effect
            ctx.shadowBlur = settings.glowIntensity;
            ctx.shadowColor = settings.glowColor;
            ctx.strokeStyle = settings.glowColor;
            ctx.lineWidth = settings.lineThickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw connections
            connections.forEach(([start, end]) => {
                if (landmarks[start] && landmarks[end]) {
                    const startPoint = transform(landmarks[start]);
                    const endPoint = transform(landmarks[end]);

                    if (landmarks[start].visibility > 0.3 && landmarks[end].visibility > 0.3) {
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(endPoint.x, endPoint.y);
                        ctx.stroke();
                    }
                }
            });

            // Draw joints
            ctx.fillStyle = settings.glowColor;
            landmarks.forEach((landmark, index) => {
                if (index >= 11 && landmark.visibility > 0.3) {
                    const point = transform(landmark);
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, settings.lineThickness * 2.5, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            ctx.shadowBlur = 0;
        }

        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            clearMedia();

            if (file.type.startsWith('image/')) {
                await handleImage(file);
            } else if (file.type.startsWith('video/')) {
                await handleVideo(file);
            }
        });

        // Handle image upload
        async function handleImage(file) {
            mediaType = 'image';
            const img = new Image();
            const url = URL.createObjectURL(file);

            img.onload = async () => {
                const originalContainer = document.getElementById('originalContainer');
                originalContainer.innerHTML = '';
                originalContainer.appendChild(img);

                currentMedia = img;

                // Show processing control instead of auto-processing
                document.getElementById('mediaInfo').textContent = 'Image loaded!';
                document.getElementById('processingControl').classList.remove('hidden');
                document.getElementById('exportImageBtn').disabled = true;
                document.getElementById('exportVideoBtn').disabled = true;

                URL.revokeObjectURL(url);
            };

            img.src = url;
        }

        // Handle video upload with optimization
        async function handleVideo(file) {
            mediaType = 'video';
            const video = document.createElement('video');
            const url = URL.createObjectURL(file);

            video.onloadedmetadata = async () => {
                originalVideoDuration = video.duration;

                if (video.duration > 45) {
                    document.getElementById('videoWarning').classList.remove('hidden');
                } else {
                    document.getElementById('videoWarning').classList.add('hidden');
                }

                const originalContainer = document.getElementById('originalContainer');
                originalContainer.innerHTML = '';
                video.controls = true;
                video.loop = true;
                originalContainer.appendChild(video);

                currentMedia = video;

                // Show processing control with video info
                const duration = Math.round(video.duration);
                document.getElementById('mediaInfo').textContent = `Video loaded! (${duration} seconds)`;
                document.getElementById('processingControl').classList.remove('hidden');
                document.getElementById('exportImageBtn').disabled = true;
                document.getElementById('exportVideoBtn').disabled = true;

                URL.revokeObjectURL(url);
            };

            video.src = url;
        }

        // Optimized video processing with strategic frame skipping
        async function processVideoFrames(video) {
            videoFrames = [];
            processedPoses = [];
            
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressContainer.style.display = 'block';
            isProcessing = true;

            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            video.currentTime = 0;
            await new Promise(resolve => video.onseeked = resolve);

            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            outputCanvas.width = video.videoWidth;
            outputCanvas.height = video.videoHeight;

            // Determine processing strategy
            let frameSkip = 1;
            switch(settings.processingQuality) {
                case 'fast':
                    frameSkip = 3;
                    break;
                case 'balanced':
                    frameSkip = 2;
                    break;
                case 'smooth':
                    frameSkip = 1;
                    break;
            }

            const outputFPS = parseInt(settings.outputFPS);
            const frameDuration = 1 / outputFPS;
            const totalFrames = Math.floor(video.duration * outputFPS);
            
            statusMessage.textContent = `Processing (${settings.processingQuality} mode, every ${frameSkip === 1 ? '' : frameSkip + ' '}frame${frameSkip > 1 ? 's' : ''})...`;

            // Process frames strategically
            for (let i = 0; i < totalFrames; i += frameSkip) {
                video.currentTime = i * frameDuration;
                await new Promise(resolve => video.onseeked = resolve);

                tempCtx.drawImage(video, 0, 0);
                
                currentPoseLandmarks = null;
                await pose.send({image: tempCanvas});
                
                // Wait a bit for pose detection to complete
                await new Promise(resolve => setTimeout(resolve, 20));

                if (currentPoseLandmarks) {
                    processedPoses.push(JSON.parse(JSON.stringify(currentPoseLandmarks)));
                }

                const progress = Math.round(((i + frameSkip) / totalFrames) * 100);
                progressFill.style.width = `${Math.min(progress, 100)}%`;
                progressFill.textContent = `${Math.min(progress, 100)}%`;
            }

            // Generate all output frames with interpolation
            statusMessage.textContent = 'Generating smooth output frames...';
            
            for (let i = 0; i < totalFrames; i++) {
                const interpolatedPose = getInterpolatedPose(i);
                
                if (interpolatedPose) {
                    ctx.fillStyle = settings.bgColor;
                    ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
                    drawGlowingStickFigure(interpolatedPose);
                }

                const frameData = outputCanvas.toDataURL('image/jpeg', 0.85); // JPEG for smaller size
                videoFrames.push(frameData);

                const progress = Math.round(((i + 1) / totalFrames) * 100);
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${progress}%`;
            }

            isProcessing = false;
            progressContainer.style.display = 'none';
            statusMessage.textContent = `‚úÖ Processed ${totalFrames} frames! Ready to export.`;

            document.getElementById('exportImageBtn').disabled = false;
            document.getElementById('exportVideoBtn').disabled = false;

            playProcessedVideo(outputFPS);

            // Sync with original video
            video.addEventListener('play', () => playProcessedVideo(outputFPS));
            video.addEventListener('pause', pauseProcessedVideo);
            video.addEventListener('seeked', () => {
                const frameIndex = Math.floor(video.currentTime * outputFPS);
                showFrame(frameIndex);
            });
        }

        // Play processed video at correct FPS
        function playProcessedVideo(fps = 30) {
            if (animationId) cancelAnimationFrame(animationId);
            
            const frameDuration = 1000 / fps;
            let lastFrameTime = performance.now();
            let frameIndex = 0;

            function animate(currentTime) {
                const elapsed = currentTime - lastFrameTime;

                if (elapsed >= frameDuration) {
                    frameIndex = (frameIndex + 1) % videoFrames.length;
                    showFrame(frameIndex);
                    lastFrameTime = currentTime - (elapsed % frameDuration); // Carry over remainder
                }

                animationId = requestAnimationFrame(animate);
            }

            animationId = requestAnimationFrame(animate);
        }

        function pauseProcessedVideo() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        function showFrame(index) {
            if (videoFrames[index]) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                };
                img.src = videoFrames[index];
            }
        }

        // Export as image
        document.getElementById('exportImageBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `matchstick-optimized-${Date.now()}.png`;
            link.href = outputCanvas.toDataURL('image/png');
            link.click();
        });

        // FFmpeg instance
        let ffmpeg = null;
        let ffmpegLoaded = false;

        // Initialize FFmpeg
        async function loadFFmpeg() {
            if (ffmpegLoaded) return;
            
            const { FFmpeg } = FFmpegWASM;
            const { toBlobURL, fetchFile } = FFmpegUtil;
            
            ffmpeg = new FFmpeg();
            
            const baseURL = 'https://cdn.jsdelivr.net/npm/@ffmpeg/core@0.12.6/dist/umd';
            
            ffmpeg.on('log', ({ message }) => {
                console.log(message);
            });
            
            ffmpeg.on('progress', ({ progress }) => {
                const percent = Math.round(progress * 100);
                const progressFill = document.getElementById('progressFill');
                const statusMessage = document.getElementById('statusMessage');
                if (progressFill && statusMessage) {
                    progressFill.style.width = `${percent}%`;
                    progressFill.textContent = `${percent}%`;
                    statusMessage.textContent = `Encoding video with FFmpeg... ${percent}%`;
                }
            });

            try {
                await ffmpeg.load({
                    coreURL: await toBlobURL(`${baseURL}/ffmpeg-core.js`, 'text/javascript'),
                    wasmURL: await toBlobURL(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm'),
                });
                ffmpegLoaded = true;
                console.log('FFmpeg loaded successfully');
            } catch (error) {
                console.error('Failed to load FFmpeg:', error);
                ffmpegLoaded = false;
            }
        }

        // Export as video using FFmpeg for proper encoding
        document.getElementById('exportVideoBtn').addEventListener('click', async () => {
            if (videoFrames.length === 0) return;

            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressContainer.style.display = 'block';
            
            try {
                // Load FFmpeg if not already loaded
                if (!ffmpegLoaded) {
                    statusMessage.textContent = 'Loading video encoder (first time only)...';
                    progressFill.style.width = '0%';
                    progressFill.textContent = 'Loading...';
                    await loadFFmpeg();
                }

                if (!ffmpegLoaded) {
                    // Fallback to MediaRecorder if FFmpeg fails to load
                    statusMessage.textContent = 'Using fallback encoder...';
                    await exportVideoMediaRecorder();
                    return;
                }

                statusMessage.textContent = 'Preparing frames for encoding...';
                
                const fps = parseInt(settings.outputFPS);
                
                // Write all frames to FFmpeg virtual filesystem
                for (let i = 0; i < videoFrames.length; i++) {
                    // Convert base64 to blob
                    const response = await fetch(videoFrames[i]);
                    const blob = await response.blob();
                    const arrayBuffer = await blob.arrayBuffer();
                    const uint8Array = new Uint8Array(arrayBuffer);
                    
                    // Write frame to FFmpeg
                    const filename = `frame${String(i).padStart(5, '0')}.jpg`;
                    await ffmpeg.writeFile(filename, uint8Array);
                    
                    if (i % 10 === 0) {
                        const progress = Math.round((i / videoFrames.length) * 50); // 0-50% for frame prep
                        progressFill.style.width = `${progress}%`;
                        progressFill.textContent = `${progress}%`;
                        statusMessage.textContent = `Preparing frames... ${i + 1}/${videoFrames.length}`;
                    }
                }

                statusMessage.textContent = 'Encoding video with FFmpeg...';
                
                // Run FFmpeg to create MP4 with exact frame rate
                // -framerate: input frame rate
                // -i: input pattern
                // -c:v libx264: use H.264 codec
                // -preset fast: encoding speed preset
                // -pix_fmt yuv420p: pixel format for compatibility
                // -r: output frame rate
                // -b:v: video bitrate
                await ffmpeg.exec([
                    '-framerate', String(fps),
                    '-i', 'frame%05d.jpg',
                    '-c:v', 'libx264',
                    '-preset', 'fast',
                    '-pix_fmt', 'yuv420p',
                    '-r', String(fps),
                    '-b:v', '8M',
                    'output.mp4'
                ]);

                // Read the output file
                const data = await ffmpeg.readFile('output.mp4');
                
                // Create download link
                const blob = new Blob([data.buffer], { type: 'video/mp4' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `matchstick-optimized-${Date.now()}.mp4`;
                link.click();
                URL.revokeObjectURL(url);

                // Cleanup FFmpeg filesystem
                statusMessage.textContent = 'Cleaning up...';
                for (let i = 0; i < videoFrames.length; i++) {
                    const filename = `frame${String(i).padStart(5, '0')}.jpg`;
                    try {
                        await ffmpeg.deleteFile(filename);
                    } catch (e) {
                        // Ignore errors during cleanup
                    }
                }
                try {
                    await ffmpeg.deleteFile('output.mp4');
                } catch (e) {
                    // Ignore
                }

                progressContainer.style.display = 'none';
                statusMessage.textContent = '‚úÖ High-quality MP4 video exported successfully!';

            } catch (error) {
                console.error('FFmpeg export error:', error);
                statusMessage.textContent = '‚ùå Error during encoding. Using fallback method...';
                await exportVideoMediaRecorder();
            }
        });

        // Fallback: Original MediaRecorder method
        async function exportVideoMediaRecorder() {
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressContainer.style.display = 'block';
            statusMessage.textContent = 'Encoding video (fallback method)...';

            const fps = parseInt(settings.outputFPS);
            const stream = outputCanvas.captureStream(fps);
            
            const mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 5000000
            });

            const chunks = [];
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `matchstick-optimized-${Date.now()}.webm`;
                link.click();
                URL.revokeObjectURL(url);

                progressContainer.style.display = 'none';
                statusMessage.textContent = '‚úÖ Video exported (WebM format)';
            };

            mediaRecorder.start();

            const frameDelay = 1000 / fps;
            for (let i = 0; i < videoFrames.length; i++) {
                showFrame(i);
                await new Promise(resolve => setTimeout(resolve, frameDelay));
                
                const progress = Math.round(((i + 1) / videoFrames.length) * 100);
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${progress}%`;
            }

            mediaRecorder.stop();
        }

        function clearMedia() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            videoFrames = [];
            processedPoses = [];
            currentFrame = 0;
            currentMedia = null;
            currentPoseLandmarks = null;
            
            document.getElementById('exportImageBtn').disabled = true;
            document.getElementById('exportVideoBtn').disabled = true;
            document.getElementById('videoWarning').classList.add('hidden');
            document.getElementById('processingControl').classList.add('hidden');
        }

        // Start Processing button handler
        document.getElementById('startProcessingBtn').addEventListener('click', async () => {
            if (!currentMedia) return;

            // Hide the processing control
            document.getElementById('processingControl').classList.add('hidden');

            // Initialize pose detector if not already done
            if (!pose) await initPose();

            // Process based on media type
            if (mediaType === 'image') {
                await pose.send({image: currentMedia});
                document.getElementById('exportImageBtn').disabled = false;
                document.getElementById('exportVideoBtn').disabled = true;
            } else if (mediaType === 'video') {
                await processVideoFrames(currentMedia);
            }
        });

        // Settings updates
        document.getElementById('glowColor').addEventListener('input', (e) => {
            settings.glowColor = e.target.value;
            document.getElementById('glowColorLabel').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('bgColor').addEventListener('input', (e) => {
            settings.bgColor = e.target.value;
            document.getElementById('bgColorLabel').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('glowIntensity').addEventListener('input', (e) => {
            settings.glowIntensity = parseInt(e.target.value);
            document.getElementById('glowValue').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('lineThickness').addEventListener('input', (e) => {
            settings.lineThickness = parseInt(e.target.value);
            document.getElementById('thicknessValue').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('figureScale').addEventListener('input', (e) => {
            settings.figureScale = parseInt(e.target.value) / 100;
            document.getElementById('scaleValue').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('processingQuality').addEventListener('change', (e) => {
            settings.processingQuality = e.target.value;
        });

        document.getElementById('outputFPS').addEventListener('change', (e) => {
            settings.outputFPS = e.target.value;
        });

        document.getElementById('interpolationLevel').addEventListener('change', (e) => {
            settings.interpolationLevel = parseInt(e.target.value);
        });

        // Initialize
        window.addEventListener('load', () => {
            initPose();
        });
    </script>
</body>
</html>
