<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matchstick Motion Pro - Smooth & High Quality</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            color: white;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .subtitle {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 5px 15px;
            border-radius: 20px;
            margin-top: 10px;
            font-size: 0.9em;
        }

        .controls {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .upload-section {
            text-align: center;
            margin-bottom: 20px;
        }

        .upload-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }

        .file-input {
            display: none;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .setting-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .setting-group label {
            font-weight: 600;
            color: #333;
            font-size: 0.9em;
        }

        .color-picker-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        input[type="color"] {
            width: 60px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
        }

        .color-label {
            padding: 8px 15px;
            background: #f0f0f0;
            border-radius: 8px;
            font-size: 0.9em;
            flex: 1;
        }

        input[type="range"] {
            width: 100%;
        }

        select {
            padding: 8px 12px;
            border-radius: 8px;
            border: 2px solid #ddd;
            font-size: 0.9em;
        }

        .panels {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .panel h2 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.3em;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            aspect-ratio: 16/9;
            background: #f5f5f5;
            border-radius: 10px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        canvas, video, img {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }

        .placeholder {
            color: #999;
            text-align: center;
            padding: 40px;
        }

        .export-section {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            text-align: center;
        }

        .export-btn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 15px 40px;
            border: none;
            border-radius: 50px;
            font-size: 1.1em;
            cursor: pointer;
            margin: 10px;
            transition: transform 0.2s;
            box-shadow: 0 4px 15px rgba(245, 87, 108, 0.4);
        }

        .export-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(245, 87, 108, 0.6);
        }

        .export-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-container {
            margin: 20px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .status-message {
            margin-top: 15px;
            color: #666;
            font-size: 0.95em;
        }

        .warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #856404;
        }

        .info-box {
            background: #d1ecf1;
            border: 2px solid #17a2b8;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #0c5460;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 768px) {
            .panels {
                grid-template-columns: 1fr;
            }
            
            h1 {
                font-size: 1.8em;
            }
            
            .settings-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üï∫ Matchstick Motion PRO</h1>
            <p class="subtitle">Smooth, High-Quality Glowing Stick Figures</p>
            <div class="badge">‚ú® 60 FPS ‚Ä¢ Pose Smoothing ‚Ä¢ Enhanced Quality</div>
        </header>

        <div class="info-box">
            <strong>üéâ NEW IMPROVEMENTS:</strong> Smoother animations, bigger figures, better tracking, and higher quality output!
        </div>

        <div class="controls">
            <div class="upload-section">
                <button class="upload-btn" onclick="document.getElementById('fileInput').click()">
                    üìÅ Upload Photo or Video
                </button>
                <input type="file" id="fileInput" class="file-input" accept="image/*,video/*">
                <p style="margin-top: 10px; color: #666; font-size: 0.9em;">
                    Supports JPG, PNG, MP4, WebM ‚Ä¢ Recommended: 15-30 second clips for best results
                </p>
            </div>

            <div id="videoWarning" class="warning hidden">
                ‚ö†Ô∏è Your video is longer than 60 seconds. Processing may take time. Consider trimming for faster results.
            </div>

            <div class="settings-grid">
                <div class="setting-group">
                    <label>Stick Figure Glow Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="glowColor" value="#00ff88">
                        <span class="color-label" id="glowColorLabel">#00ff88</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>Background Color</label>
                    <div class="color-picker-wrapper">
                        <input type="color" id="bgColor" value="#1a1a2e">
                        <span class="color-label" id="bgColorLabel">#1a1a2e</span>
                    </div>
                </div>

                <div class="setting-group">
                    <label>Glow Intensity: <span id="glowValue">25</span>px</label>
                    <input type="range" id="glowIntensity" min="10" max="50" value="25">
                </div>

                <div class="setting-group">
                    <label>Line Thickness: <span id="thicknessValue">6</span>px</label>
                    <input type="range" id="lineThickness" min="3" max="12" value="6">
                </div>

                <div class="setting-group">
                    <label>Figure Size</label>
                    <select id="figureSize">
                        <option value="0.8">Normal (80%)</option>
                        <option value="1.0" selected>Large (100%)</option>
                        <option value="1.2">Extra Large (120%)</option>
                        <option value="1.5">Maximum (150%)</option>
                    </select>
                </div>

                <div class="setting-group">
                    <label>Smoothing Level</label>
                    <select id="smoothingLevel">
                        <option value="1">None (Fastest)</option>
                        <option value="3" selected>Medium (Balanced)</option>
                        <option value="5">High (Smoothest)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="panels">
            <div class="panel">
                <h2>üì∑ Original</h2>
                <div class="canvas-container" id="originalContainer">
                    <div class="placeholder">
                        <p>Upload a photo or video to get started!</p>
                        <p style="margin-top: 10px; font-size: 0.9em;">Best results with clear, full-body dance moves</p>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>‚ú® Matchstick Figure</h2>
                <div class="canvas-container" id="outputContainer">
                    <canvas id="outputCanvas"></canvas>
                </div>
            </div>
        </div>

        <div class="export-section">
            <h2 style="margin-bottom: 20px;">Export Your Creation</h2>
            
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill">0%</div>
                </div>
                <p class="status-message" id="statusMessage">Processing...</p>
            </div>

            <div>
                <button class="export-btn" id="exportImageBtn" disabled>
                    üì∏ Download as Image
                </button>
                <button class="export-btn" id="exportVideoBtn" disabled>
                    üé• Download as Video (High Quality)
                </button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let pose = null;
        let currentMedia = null;
        let mediaType = null;
        let isProcessing = false;
        let videoFrames = [];
        let currentFrame = 0;
        let animationId = null;
        let poseHistory = []; // For smoothing

        // Canvas and context
        const outputCanvas = document.getElementById('outputCanvas');
        const ctx = outputCanvas.getContext('2d');

        // Settings
        let settings = {
            glowColor: '#00ff88',
            bgColor: '#1a1a2e',
            glowIntensity: 25,
            lineThickness: 6,
            figureSize: 1.0,
            smoothingLevel: 3
        };

        // Initialize MediaPipe Pose with better settings
        async function initPose() {
            pose = new Pose({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/pose/${file}`;
                }
            });

            pose.setOptions({
                modelComplexity: 1,
                smoothLandmarks: true,
                enableSegmentation: false,
                smoothSegmentation: false,
                minDetectionConfidence: 0.3, // Lower threshold for more complete figures
                minTrackingConfidence: 0.3   // Better tracking
            });

            pose.onResults(onPoseResults);
        }

        // Smooth landmarks using moving average
        function smoothLandmarks(newLandmarks) {
            if (!newLandmarks) return null;

            poseHistory.push(JSON.parse(JSON.stringify(newLandmarks)));
            
            // Keep only recent frames for smoothing
            const smoothWindow = settings.smoothingLevel;
            if (poseHistory.length > smoothWindow) {
                poseHistory.shift();
            }

            // If we don't have enough history, return current
            if (poseHistory.length < 2) {
                return newLandmarks;
            }

            // Average the positions
            const smoothed = newLandmarks.map((landmark, i) => {
                let sumX = 0, sumY = 0, sumZ = 0, sumVis = 0;
                let count = 0;

                poseHistory.forEach(historyFrame => {
                    if (historyFrame[i]) {
                        sumX += historyFrame[i].x;
                        sumY += historyFrame[i].y;
                        sumZ += historyFrame[i].z || 0;
                        sumVis += historyFrame[i].visibility || 0;
                        count++;
                    }
                });

                return {
                    x: sumX / count,
                    y: sumY / count,
                    z: sumZ / count,
                    visibility: sumVis / count
                };
            });

            return smoothed;
        }

        // Handle pose detection results
        function onPoseResults(results) {
            if (!results.poseLandmarks) return;

            // Apply smoothing
            const smoothedLandmarks = smoothLandmarks(results.poseLandmarks);
            if (!smoothedLandmarks) return;

            // Set canvas size to match source
            outputCanvas.width = results.image.width;
            outputCanvas.height = results.image.height;

            // Clear and fill background
            ctx.fillStyle = settings.bgColor;
            ctx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);

            // Draw the glowing stick figure with scaling
            drawGlowingStickFigure(smoothedLandmarks);
        }

        // Calculate bounding box for scaling
        function getBoundingBox(landmarks) {
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            landmarks.forEach(landmark => {
                if (landmark.visibility > 0.2) {
                    minX = Math.min(minX, landmark.x);
                    minY = Math.min(minY, landmark.y);
                    maxX = Math.max(maxX, landmark.x);
                    maxY = Math.max(maxY, landmark.y);
                }
            });

            return { minX, minY, maxX, maxY };
        }

        // Draw glowing stick figure with improved quality and size
        function drawGlowingStickFigure(landmarks) {
            const w = outputCanvas.width;
            const h = outputCanvas.height;

            // Get bounding box for centering and scaling
            const bbox = getBoundingBox(landmarks);
            const bboxWidth = bbox.maxX - bbox.minX;
            const bboxHeight = bbox.maxY - bbox.minY;
            const centerX = (bbox.minX + bbox.maxX) / 2;
            const centerY = (bbox.minY + bbox.maxY) / 2;

            // Calculate scale to make figure larger
            const baseScale = Math.min(w / (bboxWidth * w), h / (bboxHeight * h)) * 0.8;
            const scale = baseScale * settings.figureSize;

            // Transform function to scale and center
            const transform = (landmark) => {
                const scaledX = ((landmark.x - centerX) * scale) + 0.5;
                const scaledY = ((landmark.y - centerY) * scale) + 0.5;
                return {
                    x: scaledX * w,
                    y: scaledY * h,
                    visibility: landmark.visibility
                };
            };

            // Define comprehensive connections between body points
            const connections = [
                // Core body
                [11, 12], // shoulders
                [11, 23], [12, 24], // torso
                [23, 24], // hips
                
                // Left arm
                [11, 13], [13, 15], // shoulder to elbow to wrist
                [15, 17], [15, 19], [15, 21], // hand details
                
                // Right arm
                [12, 14], [14, 16], // shoulder to elbow to wrist
                [16, 18], [16, 20], [16, 22], // hand details
                
                // Left leg
                [23, 25], [25, 27], // hip to knee to ankle
                [27, 29], [27, 31], // foot details
                
                // Right leg
                [24, 26], [26, 28], // hip to knee to ankle
                [28, 30], [28, 32], // foot details
                
                // Head/neck (optional, can be commented out)
                [0, 1], [1, 2], [2, 3],
                [0, 4], [4, 5], [5, 6],
                [9, 10] // mouth
            ];

            // Setup enhanced glow effect
            ctx.shadowBlur = settings.glowIntensity;
            ctx.shadowColor = settings.glowColor;
            ctx.strokeStyle = settings.glowColor;
            ctx.lineWidth = settings.lineThickness;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Draw connections with better quality
            connections.forEach(([start, end]) => {
                if (landmarks[start] && landmarks[end]) {
                    const startPoint = transform(landmarks[start]);
                    const endPoint = transform(landmarks[end]);

                    // Lower visibility threshold for more complete figure
                    if (landmarks[start].visibility > 0.2 && landmarks[end].visibility > 0.2) {
                        ctx.beginPath();
                        ctx.moveTo(startPoint.x, startPoint.y);
                        ctx.lineTo(endPoint.x, endPoint.y);
                        ctx.stroke();
                    }
                }
            });

            // Draw joints as larger circles for better visibility
            ctx.fillStyle = settings.glowColor;
            landmarks.forEach((landmark, index) => {
                // Draw all main body joints
                if (index >= 11 && landmark.visibility > 0.2) {
                    const point = transform(landmark);
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, settings.lineThickness * 2, 0, 2 * Math.PI);
                    ctx.fill();
                }
            });

            // Reset shadow for clean rendering
            ctx.shadowBlur = 0;
        }

        // Handle file upload
        document.getElementById('fileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Clear previous media
            clearMedia();

            // Check file type
            if (file.type.startsWith('image/')) {
                await handleImage(file);
            } else if (file.type.startsWith('video/')) {
                await handleVideo(file);
            }
        });

        // Handle image upload
        async function handleImage(file) {
            mediaType = 'image';
            poseHistory = []; // Reset smoothing history
            
            const img = new Image();
            const url = URL.createObjectURL(file);

            img.onload = async () => {
                // Display original
                const originalContainer = document.getElementById('originalContainer');
                originalContainer.innerHTML = '';
                originalContainer.appendChild(img);

                currentMedia = img;

                // Process image
                if (!pose) await initPose();
                await pose.send({image: img});

                // Enable export buttons
                document.getElementById('exportImageBtn').disabled = false;
                document.getElementById('exportVideoBtn').disabled = true;

                URL.revokeObjectURL(url);
            };

            img.src = url;
        }

        // Handle video upload with improved processing
        async function handleVideo(file) {
            mediaType = 'video';
            poseHistory = []; // Reset smoothing history
            
            const video = document.createElement('video');
            const url = URL.createObjectURL(file);

            video.onloadedmetadata = async () => {
                // Check duration
                if (video.duration > 60) {
                    document.getElementById('videoWarning').classList.remove('hidden');
                } else {
                    document.getElementById('videoWarning').classList.add('hidden');
                }

                // Display original
                const originalContainer = document.getElementById('originalContainer');
                originalContainer.innerHTML = '';
                video.controls = true;
                video.loop = true;
                originalContainer.appendChild(video);

                currentMedia = video;

                // Initialize pose detector
                if (!pose) await initPose();

                // Process video frames at higher FPS
                await processVideoFrames(video);

                URL.revokeObjectURL(url);
            };

            video.src = url;
        }

        // Process video frame by frame with 60 FPS
        async function processVideoFrames(video) {
            videoFrames = [];
            poseHistory = []; // Reset for fresh smoothing
            
            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressContainer.style.display = 'block';
            isProcessing = true;

            // Create temporary canvas for frame capture
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            video.currentTime = 0;
            await new Promise(resolve => {
                video.onseeked = resolve;
            });

            tempCanvas.width = video.videoWidth;
            tempCanvas.height = video.videoHeight;
            outputCanvas.width = video.videoWidth;
            outputCanvas.height = video.videoHeight;

            const fps = 60; // Increased from 30 to 60 for smoother motion
            const frameDuration = 1 / fps;
            const totalFrames = Math.floor(video.duration * fps);

            statusMessage.textContent = `Processing at 60 FPS... 0/${totalFrames} frames`;

            for (let i = 0; i < totalFrames; i++) {
                video.currentTime = i * frameDuration;
                
                await new Promise(resolve => {
                    video.onseeked = resolve;
                });

                // Draw current frame to temp canvas
                tempCtx.drawImage(video, 0, 0);

                // Process with pose detection
                await pose.send({image: tempCanvas});

                // Small delay to ensure processing completes
                await new Promise(resolve => setTimeout(resolve, 10));

                // Save the processed frame
                const frameData = outputCanvas.toDataURL('image/png');
                videoFrames.push(frameData);

                // Update progress
                const progress = Math.round(((i + 1) / totalFrames) * 100);
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${progress}%`;
                statusMessage.textContent = `Processing at 60 FPS... ${i + 1}/${totalFrames} frames`;
            }

            isProcessing = false;
            progressContainer.style.display = 'none';
            statusMessage.textContent = `‚úÖ Video processed with ${totalFrames} frames! Ready to export.`;

            // Enable export buttons
            document.getElementById('exportImageBtn').disabled = false;
            document.getElementById('exportVideoBtn').disabled = false;

            // Start playback
            playProcessedVideo();

            // Sync with original video
            video.addEventListener('play', playProcessedVideo);
            video.addEventListener('pause', pauseProcessedVideo);
            video.addEventListener('seeked', () => {
                const frameIndex = Math.floor(video.currentTime * fps);
                showFrame(frameIndex);
            });
        }

        // Play processed video at 60 FPS
        function playProcessedVideo() {
            if (animationId) cancelAnimationFrame(animationId);
            
            const fps = 60;
            const frameDuration = 1000 / fps;
            let lastFrameTime = Date.now();

            function animate() {
                const now = Date.now();
                const elapsed = now - lastFrameTime;

                if (elapsed >= frameDuration) {
                    currentFrame = (currentFrame + 1) % videoFrames.length;
                    showFrame(currentFrame);
                    lastFrameTime = now;
                }

                animationId = requestAnimationFrame(animate);
            }

            animate();
        }

        // Pause processed video
        function pauseProcessedVideo() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }

        // Show specific frame
        function showFrame(index) {
            if (videoFrames[index]) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0);
                };
                img.src = videoFrames[index];
            }
        }

        // Export as image
        document.getElementById('exportImageBtn').addEventListener('click', () => {
            const link = document.createElement('a');
            link.download = `matchstick-pro-${Date.now()}.png`;
            link.href = outputCanvas.toDataURL('image/png');
            link.click();
        });

        // Export as high-quality video
        document.getElementById('exportVideoBtn').addEventListener('click', async () => {
            if (videoFrames.length === 0) return;

            const progressContainer = document.getElementById('progressContainer');
            const progressFill = document.getElementById('progressFill');
            const statusMessage = document.getElementById('statusMessage');

            progressContainer.style.display = 'block';
            statusMessage.textContent = 'Creating high-quality video...';

            // Create video from frames using MediaRecorder with higher bitrate
            const stream = outputCanvas.captureStream(60); // 60 FPS stream
            const mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp9',
                videoBitsPerSecond: 8000000 // Increased bitrate for better quality
            });

            const chunks = [];
            mediaRecorder.ondataavailable = (e) => chunks.push(e.data);
            
            mediaRecorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `matchstick-pro-${Date.now()}.webm`;
                link.click();
                URL.revokeObjectURL(url);

                progressContainer.style.display = 'none';
                statusMessage.textContent = '‚úÖ High-quality video exported successfully!';
            };

            mediaRecorder.start();

            // Play through all frames at 60 FPS
            const frameDelay = 1000 / 60;
            for (let i = 0; i < videoFrames.length; i++) {
                showFrame(i);
                await new Promise(resolve => setTimeout(resolve, frameDelay));
                
                const progress = Math.round(((i + 1) / videoFrames.length) * 100);
                progressFill.style.width = `${progress}%`;
                progressFill.textContent = `${progress}%`;
            }

            mediaRecorder.stop();
        });

        // Clear media
        function clearMedia() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            videoFrames = [];
            currentFrame = 0;
            currentMedia = null;
            poseHistory = [];
            
            document.getElementById('exportImageBtn').disabled = true;
            document.getElementById('exportVideoBtn').disabled = true;
            document.getElementById('videoWarning').classList.add('hidden');
        }

        // Update settings with real-time preview
        document.getElementById('glowColor').addEventListener('input', (e) => {
            settings.glowColor = e.target.value;
            document.getElementById('glowColorLabel').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                poseHistory = [];
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('bgColor').addEventListener('input', (e) => {
            settings.bgColor = e.target.value;
            document.getElementById('bgColorLabel').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                poseHistory = [];
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('glowIntensity').addEventListener('input', (e) => {
            settings.glowIntensity = parseInt(e.target.value);
            document.getElementById('glowValue').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                poseHistory = [];
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('lineThickness').addEventListener('input', (e) => {
            settings.lineThickness = parseInt(e.target.value);
            document.getElementById('thicknessValue').textContent = e.target.value;
            if (currentMedia && mediaType === 'image') {
                poseHistory = [];
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('figureSize').addEventListener('change', (e) => {
            settings.figureSize = parseFloat(e.target.value);
            if (currentMedia && mediaType === 'image') {
                poseHistory = [];
                pose.send({image: currentMedia});
            }
        });

        document.getElementById('smoothingLevel').addEventListener('change', (e) => {
            settings.smoothingLevel = parseInt(e.target.value);
        });

        // Initialize on load
        window.addEventListener('load', () => {
            initPose();
        });
    </script>
</body>
</html>
